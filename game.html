<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Crownex Pro - Absolute Sync</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&family=Roboto:wght@400;500;700;900&display=swap" rel="stylesheet">
    <style>
        /* CSS CORE */
        html, body { touch-action: pan-x pan-y; overscroll-behavior: none; height: 100%; overflow: hidden; background-color: #0b0f19; }
        body { color: #d1d5db; font-family: 'Roboto', sans-serif; display: flex; flex-direction: column; }
        .font-mono { font-family: 'IBM Plex Mono', monospace; }
        .pb-safe { padding-bottom: env(safe-area-inset-bottom, 20px); }

        /* SIDEBAR & UI */
        #sidebar { transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1); }
        .menu-item { display: flex; align-items: center; gap: 12px; padding: 12px 16px; border-radius: 8px; color: #9ca3af; font-weight: 500; font-size: 14px; transition: all 0.2s; }
        .menu-item:active { background: #1e232e; color: white; }
        .menu-item.active { background: #1e232e; color: #FCD535; border: 1px solid #2d3442; }

        /* TECH BORDER */
        .tech-border { position: relative; background: #13161f; border: 1px solid #2a2e39; box-shadow: 0 20px 50px rgba(0,0,0,0.8); border-radius: 16px; overflow: hidden; }
        .tech-border.win { border: 1px solid #0ECB81; box-shadow: 0 0 30px rgba(14, 203, 129, 0.15); }
        .tech-border.lose { border: 1px solid #F6465D; box-shadow: 0 0 30px rgba(246, 70, 93, 0.15); }
        
        .btn-trade { transition: all 0.1s; position: relative; overflow: hidden; border-bottom: 3px solid rgba(0,0,0,0.2); }
        .btn-trade:active { transform: translateY(2px); border-bottom-width: 1px; }
        .btn-trade.dimmed { opacity: 0.3; filter: grayscale(1); pointer-events: none; }
        .btn-trade.locked { opacity: 0.5; cursor: not-allowed; filter: grayscale(0.8); }

        /* HISTORY */
        .history-wrapper { width: 100%; height: 100%; overflow-x: auto; display: flex; align-items: center; justify-content: center; }
        .history-container { display: flex; flex-direction: row; gap: 4px; padding: 0 5px; }
        .history-block { display: grid; grid-template-rows: repeat(5, 1fr); grid-template-columns: repeat(4, 1fr); grid-auto-flow: column; gap: 3px; width: 68px; height: 85px; background: rgba(255,255,255,0.02); padding: 4px; border-radius: 6px; border: 1px solid #1f2430; }
        .dot { width: 10px; height: 10px; border-radius: 50%; background-color: #232836; margin: auto; box-shadow: inset 0 2px 4px rgba(0,0,0,0.3); }
        .dot.up { background-color: #0ECB81; box-shadow: 0 0 5px rgba(14, 203, 129, 0.5); } 
        .dot.down { background-color: #F6465D; box-shadow: 0 0 5px rgba(246, 70, 93, 0.5); }
        
        /* CHART ELEMENTS */
        #lockLine { position: absolute; left: 0; right: 0; height: 1px; border-top: 1px dashed #FCD535; z-index: 5; pointer-events: none; display: none; }
        #lockLabel { position: absolute; left: 10px; z-index: 6; background: #FCD535; color: #111; font-family: 'IBM Plex Mono', monospace; font-size: 10px; font-weight: bold; padding: 2px 6px; border-radius: 4px; transform: translateY(-50%); display: none; }
        
        /* CONFIRM BAR */
        #confirmBar { 
            position: fixed; bottom: 0; left: 0; right: 0; 
            background: #1e232e; 
            border-top-left-radius: 20px; border-top-right-radius: 20px;
            box-shadow: 0 -5px 30px rgba(0,0,0,0.5);
            z-index: 100;
            transform: translateY(120%);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            padding-bottom: env(safe-area-inset-bottom, 20px);
        }
        #confirmBar.active { transform: translateY(0); }
        
        /* ANIMATIONS */
        @keyframes popIn { 0% { transform: scale(0); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        .dot.new { animation: popIn 0.3s; }
        
        /* TOAST */
        #toast { position: fixed; top: 20px; left: 50%; transform: translateX(-50%) translateY(-100px); background: #1e232e; border: 1px solid #2d3442; padding: 10px 20px; border-radius: 50px; display: flex; align-items: center; gap: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); z-index: 100; opacity: 0; transition: all 0.4s; pointer-events: none;}
        #toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }
        #toast.error i { color: #F6465D; } #toast.success i { color: #0ECB81; }
        
        .btn-loading { pointer-events: none; opacity: 0.7; }
        
        /* QUICK SELECT */
        .chip { background: #232836; color: #9ca3af; padding: 4px 12px; border-radius: 4px; font-size: 11px; font-weight: bold; border: 1px solid #2d3442; transition: all 0.2s; }
        .chip:active { background: #FCD535; color: black; border-color: #FCD535; }

        #pageLoader { position: fixed; inset: 0; background: #0b0f19; z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.5s; }
    </style>
</head>
<body>

    <!-- LOADING SCREEN -->
    <div id="pageLoader">
        <div class="w-12 h-12 rounded bg-[#FCD535] flex items-center justify-center text-black font-bold text-2xl animate-bounce rounded-bl-none">C</div>
        <div class="text-[#6b7280] text-xs font-mono mt-4 font-bold tracking-widest">SYNCING DATA...</div>
    </div>

    <!-- TOAST -->
    <div id="toast"><i class="fa-solid fa-circle-check text-lg"></i><span class="text-sm font-bold text-white" id="toastMsg">...</span></div>

    <!-- SIDEBAR -->
    <div id="sidebarOverlay" class="fixed inset-0 bg-black/80 z-40 hidden opacity-0 transition-opacity duration-300" onclick="window.toggleMenu()"></div>
    <div id="sidebar" class="fixed top-0 left-0 w-[80%] max-w-xs h-full bg-[#13161f] z-50 transform -translate-x-full shadow-2xl border-r border-[#232836] flex flex-col">
        <div class="h-16 flex items-center px-6 border-b border-[#232836] bg-[#171b26]">
            <div class="w-8 h-8 rounded bg-[#FCD535] flex items-center justify-center text-black font-bold text-xl rounded-bl-none mr-3">C</div>
            <span class="font-bold text-lg text-white">CROWNEX</span>
            <button onclick="window.toggleMenu()" class="ml-auto text-gray-500 w-8 h-8 flex items-center justify-center"><i class="fa-solid fa-xmark text-xl"></i></button>
        </div>
        <nav class="flex-1 overflow-y-auto py-4 px-3 space-y-1">
            <a href="#" class="menu-item active"><i class="fa-solid fa-chart-line"></i> Giao dịch</a>
            <a href="#" class="menu-item"><i class="fa-solid fa-user-gear"></i> Tài khoản</a>
            <a href="#" class="menu-item"><i class="fa-solid fa-money-bill-transfer"></i> Nạp / Rút tiền</a>
            <a href="#" class="menu-item"><i class="fa-solid fa-clock-rotate-left"></i> Lịch sử cược</a>
            <div class="border-t border-[#232836] my-2 mx-2"></div>
            <a href="#" onclick="window.logout()" class="menu-item text-red-400 mt-4"><i class="fa-solid fa-right-from-bracket"></i> Đăng xuất</a>
        </nav>
        <div class="p-4 border-t border-[#232836] bg-[#12141c]">
            <div class="flex items-center gap-3">
                <div class="w-9 h-9 rounded-full bg-gradient-to-tr from-gray-700 to-gray-600 flex items-center justify-center font-bold text-xs shadow-lg text-white">U</div>
                <div class="flex flex-col"><span class="text-xs font-bold text-white" id="sidebarUsername">User...</span><span class="text-[10px] text-green-500 flex items-center gap-1"><div class="w-1.5 h-1.5 rounded-full bg-green-500"></div> Online</span></div>
            </div>
        </div>
    </div>

    <!-- HEADER -->
    <header class="flex items-center justify-between px-4 h-14 bg-[#13161f] border-b border-[#232836] z-20 shrink-0">
        <div class="flex items-center gap-4">
            <button onclick="window.toggleMenu()" class="cursor-pointer w-8 h-8 flex items-center justify-center active:scale-95 transition-transform"><i class="fa-solid fa-bars-staggered text-xl text-[#9ca3af]"></i></button>
            <div class="flex flex-col justify-center">
                <div class="flex items-center gap-2">
                    <span class="text-white font-bold text-sm">BTC/USDT</span>
                    <span class="bg-[#232836] text-[#FCD535] text-[9px] px-1 rounded border border-[#2f3646] flex items-center gap-1">LIVE</span>
                </div>
                <div class="text-[10px] text-[#6b7280] font-mono leading-none mt-0.5">Phiên: <span id="sessionID" class="text-gray-400">...</span></div>
            </div>
        </div>
        <div class="bg-[#1e232e] pl-4 pr-1 py-1 rounded-full border border-[#2d3442] flex items-center gap-3">
            <div class="text-right leading-tight"><div class="text-[9px] text-[#6b7280] font-bold uppercase">Thực: <span id="balanceDisplay" class="text-[#EAECEF] font-mono text-sm">---</span></div></div>
            <div class="w-7 h-7 bg-[#FCD535] rounded-full flex items-center justify-center text-xs text-[#111]"><i class="fa-solid fa-wallet"></i></div>
        </div>
    </header>

    <!-- CHART AREA -->
    <div class="flex-1 relative bg-[#0b0f19] overflow-hidden" id="chart-wrapper">
        <div class="absolute top-3 right-[70px] z-10"><span id="candleStatusBadge" class="text-[10px] font-bold px-3 py-1 rounded-full bg-[#232836] text-[#9ca3af] border border-[#374151]">WAITING</span></div>
        <canvas id="chartCanvas" class="w-full h-full block"></canvas>
        <div id="lockLine"></div>
        <div id="lockLabel"><i class="fa-solid fa-lock text-[8px] mr-1 opacity-70"></i> <span id="lockPriceText"></span></div>
        
        <!-- WIN/LOSE POPUP -->
        <div id="resultPopup" class="hidden absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-50 w-72 text-center transition-all duration-300 scale-90 opacity-0">
            <div id="popupBorder" class="tech-border p-8 relative">
                <div id="popupTitle" class="font-black text-2xl mb-1 uppercase">HÚP RỒI</div>
                <div id="popupAmount" class="font-mono font-bold text-4xl drop-shadow-xl">+$0.00</div>
            </div>
        </div>
    </div>

    <!-- HISTORY BAR -->
    <div class="glass-panel z-20 shrink-0 h-28 flex flex-col shadow-[0_-5px_20px_rgba(0,0,0,0.5)] bg-[#13161f]">
        <div class="flex items-center justify-between px-4 py-1.5 border-b border-[#232836] bg-[#171b26]">
            <div class="flex items-center gap-2"><i class="fa-solid fa-clock-rotate-left text-[#6b7280] text-xs"></i><span class="text-[#9ca3af] text-[10px] font-bold uppercase">Kết quả bóng</span></div>
            <div class="flex gap-4 text-[10px] font-mono font-bold"><span class="text-[#0ECB81]">Xanh: <span id="count-up">0</span></span><span class="text-[#F6465D]">Đỏ: <span id="count-down">0</span></span></div>
        </div>
        <div class="flex-1 bg-[#0b0f19] flex items-center justify-center"><div class="history-wrapper"><div class="history-container" id="historyContainer"></div></div></div>
    </div>

    <!-- CONTROL PANEL -->
    <div class="bg-[#13161f] p-4 border-t border-[#232836] pb-safe z-20 shrink-0 relative">
        <div class="flex justify-between items-end mb-4">
            <div class="text-center w-full">
                <!-- QUICK SELECT BUTTONS -->
                <div class="flex items-center justify-center gap-2 mb-3">
                    <button onclick="window.setBetAmount(1)" class="chip">$1</button>
                    <button onclick="window.setBetAmount(5)" class="chip">$5</button>
                    <button onclick="window.setBetAmount(10)" class="chip">$10</button>
                    <button onclick="window.setAllIn()" class="chip text-[#FCD535] border-[#FCD535]">ALL</button>
                </div>

                <div class="flex items-center justify-center gap-2">
                    <button onclick="window.adjustBet(-1)" class="w-10 h-10 bg-[#1e232e] rounded-lg text-[#9ca3af] text-lg font-bold border border-[#2d3442] active:bg-[#2d3442]">-</button>
                    <div class="w-36 relative group">
                        <span class="absolute left-3 top-1/2 -translate-y-1/2 text-[#6b7280] font-bold font-mono text-sm">$</span>
                        <input type="number" id="betInput" value="1" class="w-full h-10 bg-[#0b0f19] border border-[#2d3442] text-white font-mono font-bold text-lg rounded-lg pl-6 text-center focus:outline-none focus:border-[#FCD535]" oninput="window.updateProfit()">
                    </div>
                    <button onclick="window.adjustBet(1)" class="w-10 h-10 bg-[#1e232e] rounded-lg text-[#9ca3af] text-lg font-bold border border-[#2d3442] active:bg-[#2d3442]">+</button>
                </div>
                <div class="text-[10px] text-[#6b7280] font-bold uppercase mt-1">Lợi nhuận: <span class="text-[#0ECB81]" id="profitDisplay">+$0.95</span> (95%)</div>
            </div>
        </div>
        
        <div class="flex gap-3 h-14 relative mb-2">
            <button id="btnSell" onclick="window.selectSide('down')" class="flex-1 btn-trade bg-[#F6465D] rounded-xl flex items-center justify-between px-4 shadow-[0_4px_0_#b9283a]">
                <div class="flex flex-col items-start"><span class="font-black text-lg text-white">BÁN</span><span class="text-[9px] text-white/70 font-mono font-bold">DOWN</span></div>
                <i class="fa-solid fa-arrow-trend-down text-2xl text-white/40"></i>
                <div id="badge-down" class="hidden absolute top-2 right-2 bg-yellow-400 text-black text-[10px] font-bold px-1 rounded shadow-lg">0$</div>
            </button>
            
            <div class="w-24 bg-[#1e232e] rounded-xl flex flex-col items-center justify-center border border-[#2d3442] relative overflow-hidden shadow-inner">
                <div id="timerProgress" class="absolute bottom-0 left-0 h-1 bg-[#FCD535] w-full transition-all duration-1000 ease-linear"></div>
                <span id="phaseText" class="text-[9px] text-[#6b7280] font-bold uppercase z-10 tracking-wider">ĐẶT LỆNH</span>
                <span id="timerText" class="text-white font-mono font-bold text-2xl z-10 leading-none mt-0.5">30</span>
            </div>
            
            <button id="btnBuy" onclick="window.selectSide('up')" class="flex-1 btn-trade bg-[#0ECB81] rounded-xl flex items-center justify-between px-4 shadow-[0_4px_0_#0aa869]">
                <div class="flex flex-col items-start"><span class="font-black text-lg text-white">MUA</span><span class="text-[9px] text-white/70 font-mono font-bold">UP</span></div>
                <i class="fa-solid fa-arrow-trend-up text-2xl text-white/40"></i>
                <div id="badge-up" class="hidden absolute top-2 right-2 bg-yellow-400 text-black text-[10px] font-bold px-1 rounded shadow-lg">0$</div>
            </button>
        </div>
    </div>

    <!-- CONFIRM BAR -->
    <div id="confirmBar" class="p-4 bg-[#1e232e] rounded-t-2xl shadow-[0_-5px_30px_rgba(0,0,0,0.5)]">
        <div class="flex justify-between items-center mb-4">
            <div class="flex flex-col">
                <span class="text-[#9ca3af] text-xs font-bold">XÁC NHẬN LỆNH</span>
                <span id="confirmType" class="text-xl font-black">---</span>
            </div>
            <div class="text-right">
                <span class="text-[#6b7280] text-[10px] font-bold">SỐ DƯ HIỆN TẠI</span>
                <div id="confirmBalance" class="text-white font-mono font-bold">---</div>
            </div>
        </div>
        
        <div class="bg-[#13161f] rounded-lg p-3 mb-4 border border-[#232836]">
            <div class="flex justify-between mb-2">
                <span class="text-[#9ca3af] text-xs">Tiền cược</span>
                <span id="confirmAmount" class="text-white font-mono font-bold">---</span>
            </div>
            <div class="flex justify-between">
                <span class="text-[#9ca3af] text-xs">Lợi nhuận dự kiến</span>
                <span id="confirmWin" class="text-[#0ECB81] font-mono font-bold">---</span>
            </div>
        </div>
        
        <div class="flex gap-3 mb-2">
            <button onclick="window.cancelSelection()" class="flex-1 py-3 bg-[#232836] rounded-xl text-[#9ca3af] font-bold text-sm">HỦY</button>
            <button id="btnConfirm" onclick="window.confirmBet()" class="flex-[2] py-3 bg-[#FCD535] rounded-xl text-black font-black text-sm shadow-lg shadow-yellow-500/20">XÁC NHẬN NGAY</button>
        </div>
    </div>

    <!-- MAIN LOGIC -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, doc, updateDoc, getDoc, onSnapshot, addDoc, collection, setDoc, increment, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
        import { getAuth, signOut, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

        // GLOBAL FLAGS
        let roundSettled = false;

        // --- GLOBAL UI FUNCTIONS ---
        window.toggleMenu = () => {
            const sb = document.getElementById('sidebar'); 
            const ov = document.getElementById('sidebarOverlay');
            if (sb.classList.contains('-translate-x-full')) { 
                sb.classList.remove('-translate-x-full'); 
                ov.classList.remove('hidden', 'opacity-0'); 
            } else { 
                sb.classList.add('-translate-x-full'); 
                ov.classList.add('opacity-0'); 
                setTimeout(()=>ov.classList.add('hidden'), 300); 
            }
        };

        window.logout = () => { 
            const auth = getAuth();
            if(auth) {
                signOut(auth).then(() => { 
                    localStorage.clear();
                    window.location.reload(); 
                });
            } else { window.location.reload(); }
        };

        window.setBetAmount = (val) => { document.getElementById('betInput').value = val; window.updateProfit(); }
        window.setAllIn = () => { document.getElementById('betInput').value = Math.floor(state.balance); window.updateProfit(); }
        window.adjustBet = (val) => {
            const inp = document.getElementById('betInput');
            let current = parseFloat(inp.value) || 0;
            let nextVal = current + val;
            if (nextVal < 1) nextVal = 1; 
            inp.value = nextVal;
            window.updateProfit();
        };
        window.updateProfit = () => {
            const val = parseFloat(document.getElementById('betInput').value) || 0;
            document.getElementById('profitDisplay').innerText = "+$" + (val * 0.95).toFixed(2);
        };
        
        // --- FIREBASE SETUP ---
        const firebaseConfig = {
            apiKey: "AIzaSyAyYO8ZhxVvOImOZveUJULkK8tdcSxo7pU",
            authDomain: "btccoinbig.firebaseapp.com",
            projectId: "btccoinbig",
            storageBucket: "btccoinbig.firebasestorage.app",
            messagingSenderId: "116892525933",
            appId: "1:116892525933:web:04b0da25f3f933ce162664",
            measurementId: "G-7Q1GBFNQ37"
        };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // CONFIG
        const CONFIG = { basePrice: 98100, chartPaddingRight: 80, gridStep: 20 };
        const state = {
            balance: 0, userData: null, currentBet: null, 
            pendingBet: { type: null, amount: 0 },
            history: new Array(60).fill(null), 
            candles: [], 
            visualPrice: CONFIG.basePrice,
            targetPrice: CONFIG.basePrice, 
            currentPhase: 'order', 
            lockPrice: 0, isProcessing: false, gameStarted: false,
            marketOffset: 0, killWhaleMode: false, totalUp: 0, totalDown: 0,
            lastRecordedEpoch: 0
        };

        // --- AUTH LOGIC ---
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                let userStr = localStorage.getItem('crownex_user_info');
                if (userStr && !user.isAnonymous) {
                    state.userData = JSON.parse(userStr);
                    finishLoading();
                } else if (user.isAnonymous) {
                    state.userData = { uid: "guest", username: "Khách", balance: 1000 };
                    finishLoading();
                } else {
                    try {
                        const docSnap = await getDoc(doc(db, "users", user.uid));
                        if(docSnap.exists()) {
                            state.userData = docSnap.data();
                            state.userData.uid = user.uid;
                            localStorage.setItem('crownex_user_info', JSON.stringify(state.userData));
                            finishLoading();
                        } else { window.logout(); }
                    } catch (e) { 
                        state.userData = { uid: "guest", username: "Khách", balance: 1000 };
                        finishLoading(); 
                    }
                }

                if(!user.isAnonymous) {
                    onSnapshot(doc(db, "users", user.uid), (doc) => {
                        if(doc.exists()) { state.balance = doc.data().balance; updateBalanceUI(); }
                    });
                }
                
                // Admin Controls
                onSnapshot(doc(db, "settings", "global"), (doc) => {
                    if(doc.exists()) { 
                        const data = doc.data();
                        state.marketOffset = data.marketOffset || 0; 
                        state.killWhaleMode = data.killWhaleMode === true;
                    }
                });
                onSnapshot(doc(db, "games", "current"), (doc) => {
                    if(doc.exists()) { state.totalUp = doc.data().totalUp || 0; state.totalDown = doc.data().totalDown || 0; }
                });
            } else { 
                signInAnonymously(auth).catch(e => console.error(e));
            }
        });

        function finishLoading() {
            document.getElementById('sidebarUsername').innerText = state.userData.fullName || state.userData.username || "Guest";
            state.balance = state.userData.balance || 0;
            updateBalanceUI();
            const loader = document.getElementById('pageLoader');
            loader.style.opacity = '0';
            setTimeout(() => loader.style.display = 'none', 500);
            if (!state.gameStarted) { initGame(); checkSavedBet(); state.gameStarted = true; }
        }

        // --- BETTING LOGIC ---
        function checkSavedBet() {
            const saved = localStorage.getItem('crownex_active_bet');
            if (!saved) return;
            const betData = JSON.parse(saved);
            const now = Date.now();
            if (betData.expires > now) {
                state.currentBet = { type: betData.type, amount: betData.amount };
                updateBetUI(betData.type, betData.amount);
            }
        }

        function updateBetUI(type, amount) {
            const id = type === 'up' ? 'badge-up' : 'badge-down';
            document.getElementById(id).innerText = amount + "$"; 
            document.getElementById(id).classList.remove('hidden');
            const otherBtn = type === 'up' ? 'btnSell' : 'btnBuy';
            document.getElementById(otherBtn).classList.add('locked');
        }

        function showToast(type, msg) {
            const t = document.getElementById('toast');
            const i = t.querySelector('i');
            document.getElementById('toastMsg').innerText = msg;
            t.className = ''; 
            if(type === 'error') { i.className = 'fa-solid fa-circle-exclamation text-lg text-[#F6465D]'; t.style.borderColor = '#F6465D'; }
            else { i.className = 'fa-solid fa-circle-check text-lg text-[#0ECB81]'; t.style.borderColor = '#0ECB81'; }
            t.classList.add('show'); setTimeout(() => t.classList.remove('show'), 3000);
        }

        window.selectSide = (type) => {
            const currentSeconds = new Date().getSeconds();
            if (currentSeconds >= 30) return showToast('error', "Đã hết thời gian cược phiên này!");

            if (state.currentPhase !== 'order') return showToast('error', "Đang chờ kết quả, vui lòng đợi!");
            if (state.currentBet && state.currentBet.type !== type) return showToast('error', "Không được cược đối nghịch!");
            
            const amount = parseFloat(document.getElementById('betInput').value);
            if (!amount || amount <= 0) return;
            if (amount < 1) return showToast('error', "Mức cược tối thiểu là $1!");
            if (amount + state.pendingBet.amount > state.balance) return showToast('error', "Số dư không đủ!");
            
            state.pendingBet.type = type; state.pendingBet.amount = amount;
            
            const typeEl = document.getElementById('confirmType');
            if(typeEl) {
                typeEl.innerText = type.toUpperCase();
                typeEl.className = type === 'up' ? 'text-[#0ECB81] font-bold uppercase text-xl' : 'text-[#F6465D] font-bold uppercase text-xl';
            }
            document.getElementById('confirmBalance').innerText = "$" + state.balance.toLocaleString('en-US');
            document.getElementById('confirmAmount').innerText = "$" + amount;
            document.getElementById('confirmWin').innerText = "+$" + (amount * 1.95).toFixed(2);
            document.getElementById('confirmBar').classList.add('active');
        };

        window.cancelSelection = () => {
            state.pendingBet = { type: null, amount: 0 };
            document.getElementById('confirmBar').classList.remove('active');
        };

        window.confirmBet = async () => {
            const currentSeconds = new Date().getSeconds();
            if (currentSeconds >= 30) {
                window.cancelSelection();
                return showToast('error', "Đã hết thời gian cược!");
            }

            if (state.isProcessing) return;
            const amount = state.pendingBet.amount;
            const type = state.pendingBet.type;

            if (amount > state.balance) { showToast('error', "Số dư không đủ!"); return; }
            if (amount < 1) { showToast('error', "Mức cược tối thiểu là $1!"); return; }

            state.isProcessing = true;
            const btn = document.getElementById('btnConfirm');
            btn.classList.add('btn-loading'); btn.innerText = "ĐANG GỬI...";

            state.balance -= amount;
            updateBalanceUI();
            
            state.pendingBet = { type: null, amount: 0 };
            document.getElementById('confirmBar').classList.remove('active');

            if(state.userData.uid && state.userData.uid !== "guest") {
                try {
                    const uRef = doc(db, "users", state.userData.uid);
                    await updateDoc(uRef, { 
                        balance: increment(-amount), betTurnover: increment(amount), betToday: increment(amount)
                    }); 
                    await setDoc(doc(db, "games", "current"), {
                        [type === 'up' ? 'totalUp' : 'totalDown']: increment(amount)
                    }, { merge: true });
                } catch(e) { console.error(e); }
            }

            if (!state.currentBet) { state.currentBet = { type: type, amount: amount }; } 
            else { state.currentBet.amount += amount; }

            const now = Date.now();
            const nextMinute = now - (now % 60000) + 60000;
            localStorage.setItem('crownex_active_bet', JSON.stringify({
                type: state.currentBet.type, amount: state.currentBet.amount, expires: nextMinute
            }));

            updateBetUI(state.currentBet.type, state.currentBet.amount);
            showToast('success', `Đã cược ${type === 'up' ? 'MUA' : 'BÁN'}: $${amount}`);
            
            state.isProcessing = false;
            btn.classList.remove('btn-loading'); btn.innerText = "XÁC NHẬN NGAY";
        };

        function updateBalanceUI() { document.getElementById('balanceDisplay').innerText = "$" + state.balance.toLocaleString('en-US', {minimumFractionDigits: 2}); }
        
        // --- ABSOLUTE SYNC ENGINE ---
        // 1. Pseudo Random Generator for Deterministic Results
        function seededRandom(seed) {
            let t = seed += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }

        // 2. The God Function: Returns the exact UP/DOWN result for any epoch
        function getDeterministicResult(epoch) {
            // Check for Kill Whale Logic override if enabled and valid for current live epoch
            // Note: Kill Whale only works for the current live round
            const isLive = epoch === Math.floor(Date.now() / 30000);
            
            if (isLive && state.killWhaleMode) {
                if (state.totalUp > state.totalDown) return { dir: 'down', force: true };
                if (state.totalDown > state.totalUp) return { dir: 'up', force: true };
            }

            // Natural Deterministic Result
            const rand = seededRandom(epoch * 12345 + 6789);
            // 50/50 Chance + Trend bias from Sin wave
            const trendBias = Math.sin(epoch * 0.1) * 0.2; // -0.2 to 0.2
            const resultVal = rand + trendBias; 
            
            return { 
                dir: resultVal > 0.5 ? 'up' : 'down', 
                force: false,
                volatility: seededRandom(epoch * 999) 
            };
        }

        function initGame() {
            // Load history from storage or regenerate
            const today = new Date().toDateString();
            const lastDay = localStorage.getItem("crownex_history_day");
            
            if (lastDay !== today) {
                state.history = new Array(60).fill(null);
                localStorage.setItem("crownex_history_day", today);
            } else {
                const h = localStorage.getItem('crownex_history_v30');
                if (h) state.history = JSON.parse(h);
            }

            resizeCanvas(); 
            window.addEventListener('resize', resizeCanvas);
            
            // Generate historical candles
            reconstructChart();

            marketLoop(); drawLoop(); 
            setInterval(syncLoop, 1000); 
            setInterval(marketLoop, 40); // 25fps for market loop
        }

        function reconstructChart() {
            const now = Date.now();
            const currentEpoch30 = Math.floor(now / 30000);
            state.candles = [];
            
            // Generate last 50 candles
            let simPrice = CONFIG.basePrice;
            for(let i = 50; i > 0; i--) {
                const ep = currentEpoch30 - i;
                const c = generateStaticCandle(ep, simPrice);
                state.candles.push(c);
                simPrice = c.close;
            }
            
            // Set start price for live animation
            const lastC = state.candles[state.candles.length-1];
            state.visualPrice = lastC.close;
            state.targetPrice = lastC.close;
            state.lockPrice = lastC.close; // Init lock price
        }

        // --- CANDLE GENERATION LOGIC ---
        function generateStaticCandle(epoch, openPrice) {
            // If it's a result epoch (Odd), the close MUST match the deterministic result of the previous Order epoch (Even)
            // Wait, standard binary option: Order (30s) -> Result (30s).
            // The result is determined by the candle that closes at the end of the Result Phase.
            
            // Determine the result for this epoch
            const det = getDeterministicResult(epoch);
            let change = (seededRandom(epoch) * 10 + 2); // Random volatility 2-12
            
            // Apply Direction
            if (det.dir === 'up') change = change;
            else change = -change;

            // If it's an even epoch (Order phase), movement is more random/flat
            if (epoch % 2 === 0) {
                // Order phase candle - generally follows previous trend or consolidates
                change = change * 0.5;
            } else {
                // Result phase candle - MUST adhere to result
                // Logic is handled by direction above.
            }

            const close = openPrice + change;
            const high = Math.max(openPrice, close) + Math.abs(seededRandom(epoch+1) * 5);
            const low = Math.min(openPrice, close) - Math.abs(seededRandom(epoch+2) * 5);
            
            return { open: openPrice, close: close, high: high, low: low, epoch: epoch };
        }

        function renderHistoryBlocks() {
            const c = document.getElementById('historyContainer'); c.innerHTML = '';
            
            let u = 0, d = 0;
            const currentMin = new Date().getMinutes();
            const now = new Date();
            const currentEpoch = Math.floor(now.getTime() / 30000);

            // Calculate Counts & Fill Data
            for(let i = 0; i < 60; i++) {
                if (state.history[i]) {
                    if(state.history[i] === 'up') u++; else d++;
                } else if (i < currentMin) {
                    // Backfill missing history for display using deterministic logic
                    // Mapping Minute to Epoch is tricky because Epoch is 30s.
                    // We need the result of the Minute.
                    // Usually 1 Result per Minute (at second 00).
                    // The result comes from the candle ending at XX:XX:00.
                    // That candle covers XX:XX-1:30 to XX:XX:00.
                    // That is an ODD epoch.
                    
                    // Simple approach: Use a hash of the minute index + hour
                    const seed = now.getHours() * 60 + i;
                    const res = seededRandom(seed) > 0.5 ? 'up' : 'down'; // Simplified for history fill
                    if(res === 'up') u++; else d++;
                }
            }

            document.getElementById('count-up').innerText = u; 
            document.getElementById('count-down').innerText = d;
            
            for(let b=0; b < 3; b++) {
                const div = document.createElement('div'); div.className = 'history-block';
                const s = b * 20;
                for(let i=s; i<s+20; i++) {
                    const d = document.createElement('div');
                    
                    if (i >= currentMin) {
                        d.className = 'dot'; // Future
                    } else {
                        let res = state.history[i];
                        if (!res) {
                            // Deterministic fill
                             const seed = now.getHours() * 60 + i;
                             res = seededRandom(seed) > 0.5 ? 'up' : 'down';
                        }
                        d.className = res === 'up' ? 'dot up' : 'dot down';
                        if(i === (currentMin - 1)) d.classList.add('new');
                    }
                    div.appendChild(d);
                }
                c.appendChild(div);
            }
        }

        function syncLoop() {
            const now = new Date();
            const s = now.getSeconds();
            const isOrder = s < 30; // 0-29
            const timeLeft = isOrder ? (30 - s) : (60 - s);

            const y = now.getFullYear(); const mo = ('0'+(now.getMonth()+1)).slice(-2);
            const da = ('0'+now.getDate()).slice(-2); const h = ('0'+now.getHours()).slice(-2);
            const mi = ('0'+now.getMinutes()).slice(-2);
            
            document.getElementById('sessionID').innerText = `${y}${mo}${da}${h}${mi}`;

            // Phase Switching Logic
            if (isOrder && state.currentPhase === 'result') { 
                startOrderPhase(); 
            } else if (!isOrder && state.currentPhase === 'order') { 
                startResultPhase(); 
            }

            document.getElementById('timerText').innerText = timeLeft < 10 ? "0" + timeLeft : timeLeft;
            const progressPercent = (timeLeft / 30) * 100;
            document.getElementById('timerProgress').style.width = progressPercent + "%";
        }

        function startOrderPhase() {
            // End of Result Phase -> Finalize Round
            finalizeRound();
            
            state.currentPhase = 'order';
            document.getElementById('phaseText').innerText = "ĐẶT LỆNH";
            document.getElementById('timerProgress').className = "absolute bottom-0 left-0 h-1 bg-[#FCD535] w-full transition-all duration-1000 ease-linear";
            document.getElementById('candleStatusBadge').innerText = "ORDERING";
            document.getElementById('candleStatusBadge').className = "text-[10px] font-bold px-3 py-1 rounded-full bg-[#0ECB81]/20 text-[#0ECB81] border border-[#0ECB81]/50";
            
            document.getElementById('lockLabel').style.display = 'none'; 
            document.getElementById('lockLine').style.display = 'none';
            state.currentBet = null;
            document.getElementById('badge-up').classList.add('hidden'); 
            document.getElementById('badge-down').classList.add('hidden');
            document.getElementById('btnBuy').classList.remove('dimmed', 'locked'); 
            document.getElementById('btnSell').classList.remove('dimmed', 'locked');
            
            // Reset totals for new round
            if(state.userData.uid && state.userData.uid !== "guest") { 
                setDoc(doc(db, "games", "current"), { totalUp: 0, totalDown: 0 }); 
            }
        }

        function startResultPhase() {
            // End of Order Phase -> Lock Price
            state.lockPrice = state.visualPrice; // Lock at current visual price
            
            state.currentPhase = 'result'; 
            window.cancelSelection();
            document.getElementById('phaseText').innerText = "CHỜ KẾT QUẢ";
            document.getElementById('timerProgress').className = "absolute bottom-0 left-0 h-1 bg-[#3b82f6] w-full transition-all duration-1000 ease-linear";
            document.getElementById('candleStatusBadge').innerText = "WAITING";
            document.getElementById('candleStatusBadge').className = "text-[10px] font-bold px-3 py-1 rounded-full bg-[#3b82f6]/20 text-[#3b82f6] border border-[#3b82f6]/50";
            
            document.getElementById('lockLabel').style.display = 'block'; 
            document.getElementById('lockLine').style.display = 'block';
            document.getElementById('lockLine').style.top = (document.getElementById('chartCanvas').height / 2) + "px"; // Temp pos, updated in drawLoop
            document.getElementById('lockPriceText').innerText = state.lockPrice.toFixed(2);
            
            document.getElementById('btnBuy').classList.add('dimmed'); 
            document.getElementById('btnSell').classList.add('dimmed');
        }

        async function finalizeRound() {
            if (roundSettled) return;
            roundSettled = true;
            
            // The result is determined by the previous phase (Result Phase, Odd Epoch)
            // But visually, we rely on where the price actually ended up.
            // Due to our marketLoop sync logic, visualPrice is GUARANTEED to be on the correct side.
            let res = state.visualPrice >= state.lockPrice ? 'up' : 'down';
            
            const m = new Date().getMinutes(); 
            let pm = m - 1; if(pm < 0) pm = 59;

            // Update History
            state.history[pm] = res;
            localStorage.setItem('crownex_history_v30', JSON.stringify(state.history));
            renderHistoryBlocks();

            if (state.currentBet) {
                const b = state.currentBet; 
                const win = (b.type === res);
                let profit = 0; let totalReturn = 0;
                
                if (win) {
                    totalReturn = b.amount * 1.95; profit = b.amount * 0.95;
                    state.balance += totalReturn; 
                    showPopup(true, profit);
                } else { showPopup(false, b.amount); }
                
                updateBalanceUI();
                localStorage.removeItem('crownex_active_bet');

                if(state.userData.uid && state.userData.uid !== "guest") {
                    try {
                        const batchPromise = [];
                        if (win) {
                             batchPromise.push(updateDoc(doc(db, "users", state.userData.uid), { balance: increment(totalReturn) }));
                        }
                        batchPromise.push(addDoc(collection(db, "users", state.userData.uid, "betHistory"), {
                            type: b.type,
                            amount: b.amount,
                            result: win ? 'win' : 'lose',
                            profit: win ? profit : -b.amount,
                            timestamp: serverTimestamp(),
                            sessionId: document.getElementById('sessionID').innerText
                        }));
                        await Promise.all(batchPromise);
                    } catch (e) { console.error(e); }
                }
            }
            
            setTimeout(() => { roundSettled = false; }, 2000);
        }

        function showPopup(w, a) {
            const p = document.getElementById('resultPopup'); const b = document.getElementById('popupBorder');
            const t = document.getElementById('popupTitle'); const m = document.getElementById('popupAmount');
            p.classList.remove('hidden', 'scale-90', 'opacity-0'); p.classList.add('scale-100', 'opacity-100');
            if (w) {
                b.className = 'tech-border p-6 relative bg-[#13161f] win'; t.innerText = "HÚP RỒI"; t.className = "text-[#0ECB81] font-black text-xl mb-2 uppercase";
                m.innerText = "+$" + a.toFixed(2); m.className = "font-mono font-bold text-4xl text-[#0ECB81]";
            } else {
                b.className = 'tech-border p-6 relative bg-[#13161f] lose'; t.innerText = "GÃY RỒI"; t.className = "text-[#F6465D] font-black text-xl mb-2 uppercase";
                m.innerText = "-$" + a.toFixed(2); m.className = "font-mono font-bold text-4xl text-[#F6465D]";
            }
            setTimeout(() => { p.classList.add('scale-90', 'opacity-0'); setTimeout(() => p.classList.add('hidden'), 300); }, 3000);
        }

        function marketLoop() {
            const now = Date.now();
            const epoch = Math.floor(now / 30000);
            const secondsInEpoch = (now % 30000) / 1000;
            const isResultPhase = (epoch % 2 !== 0); // Odd epoch = Result Phase (30-59s)

            // Calculate Target Price
            // 1. Base Noise (Natural movement)
            const t = now / 1000;
            const noise = (Math.sin(t) * 5) + (Math.sin(t * 3.5) * 3) + (Math.cos(t * 10) * 1.5);
            let target = state.visualPrice + (noise * 0.05); // Small increments

            // 2. Deterministic Force (Sync Logic)
            if (isResultPhase) {
                const det = getDeterministicResult(epoch);
                const trendDir = det.dir === 'up' ? 1 : -1;
                
                // As time runs out (approaching 30s mark of this epoch), force the price
                if (secondsInEpoch > 20) { // Last 10 seconds of result phase
                    // Calculate required position relative to lockPrice
                    const margin = 2.0; // Minimal safe margin
                    const currentDiff = state.visualPrice - state.lockPrice;
                    
                    // Logic: If trend is UP but price is DOWN (or close), pull UP hard
                    if (trendDir === 1 && currentDiff < margin) {
                        target = state.visualPrice + 0.5; // Strong pull up
                    } else if (trendDir === -1 && currentDiff > -margin) {
                        target = state.visualPrice - 0.5; // Strong pull down
                    } else {
                        // Already safe, just maintain
                        target = state.visualPrice + (Math.random() - 0.5); 
                    }
                } else {
                     // Early in result phase - gentle bias
                     target += (trendDir * 0.1);
                }
            } else {
                // Order Phase - completely natural, just drift
                target += (Math.random() - 0.5) * 2;
            }

            // Apply Admin Offset (Global Shift)
            // target += state.marketOffset; 

            // Smooth Interpolation
            state.visualPrice += (target - state.visualPrice) * 0.1;

            // --- Candle Management ---
            let lastCandle = state.candles[state.candles.length - 1];
            
            // New Candle Logic
            if (!lastCandle || lastCandle.epoch !== epoch) {
                let openPrice = lastCandle ? lastCandle.close : state.visualPrice;
                const newCandle = { epoch: epoch, open: openPrice, close: openPrice, high: openPrice, low: openPrice };
                state.candles.push(newCandle);
                if(state.candles.length > 50) state.candles.shift();
                lastCandle = newCandle;
                state.lastRecordedEpoch = epoch;
                
                // If switching to Result Phase, ensure lock price is visually consistent
                if (isResultPhase) {
                    state.lockPrice = openPrice;
                    document.getElementById('lockPriceText').innerText = state.lockPrice.toFixed(2);
                }
            }

            // Update Current Candle
            lastCandle.close = state.visualPrice;
            if (state.visualPrice > lastCandle.high) lastCandle.high = state.visualPrice;
            if (state.visualPrice < lastCandle.low) lastCandle.low = state.visualPrice;
        }

        const cvs = document.getElementById('chartCanvas'); const ctx = cvs.getContext('2d');
        function resizeCanvas() { cvs.width = cvs.parentElement.offsetWidth; cvs.height = cvs.parentElement.offsetHeight; }
        
        function drawLoop() {
            const w = (cvs.width - CONFIG.chartPaddingRight) / 30; // 30 candles visible
            const r = 100; // Price Range view
            const min = state.visualPrice - r / 2;
            
            ctx.clearRect(0, 0, cvs.width, cvs.height);
            
            // Grid
            for(let p = Math.floor(min / 20) * 20; p < min + r; p += 20) {
                const y = cvs.height - ((p - min) / r * cvs.height);
                ctx.strokeStyle = '#1e232e'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(cvs.width, y); ctx.stroke();
                ctx.fillStyle = '#4b5563'; ctx.font = '10px IBM Plex Mono'; ctx.fillText(p, cvs.width - 55, y + 4);
            }

            // Lock Line
            if (state.currentPhase === 'result') {
                const yl = cvs.height - ((state.lockPrice - min) / r * cvs.height);
                const el = document.getElementById('lockLine');
                const lb = document.getElementById('lockLabel');
                
                // Only update DOM if moved significantly to save performance
                el.style.top = yl + 'px'; lb.style.top = yl + 'px';
                
                ctx.strokeStyle = '#FCD535'; ctx.lineWidth = 1; ctx.setLineDash([4, 4]); 
                ctx.beginPath(); ctx.moveTo(0, yl); ctx.lineTo(cvs.width, yl); ctx.stroke(); ctx.setLineDash([]);
            }

            const lastIdx = state.candles.length - 1;
            for (let i = 0; i < state.candles.length; i++) {
                const dist = lastIdx - i;
                if (dist > 30) continue; 

                const x = (cvs.width - CONFIG.chartPaddingRight) - (dist * w) - (w/2);
                const c = state.candles[i];
                
                const yO = cvs.height - ((c.open - min) / r * cvs.height); 
                const yC = cvs.height - ((c.close - min) / r * cvs.height);
                const yH = cvs.height - ((c.high - min) / r * cvs.height); 
                const yL = cvs.height - ((c.low - min) / r * cvs.height);

                const isUp = c.close >= c.open;
                ctx.fillStyle = isUp ? '#0ECB81' : '#F6465D'; 
                ctx.strokeStyle = ctx.fillStyle;

                ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(x, yH); ctx.lineTo(x, yL); ctx.stroke();
                
                const bodyH = Math.max(Math.abs(yC - yO), 1);
                ctx.fillRect(x - (w/2) + 2, Math.min(yO, yC), w - 4, bodyH);
            }

            // Current Price Line
            const yc = cvs.height - ((state.visualPrice - min) / r * cvs.height);
            ctx.strokeStyle = '#fff'; ctx.setLineDash([2, 2]); ctx.beginPath(); ctx.moveTo(0, yc); ctx.lineTo(cvs.width, yc); ctx.stroke(); ctx.setLineDash([]);
            
            // Price Tag
            ctx.fillStyle = state.visualPrice >= state.candles[lastIdx].open ? '#0ECB81' : '#F6465D';
            ctx.fillRect(cvs.width - 60, yc - 10, 60, 20); 
            ctx.fillStyle = '#000'; ctx.font = 'bold 11px IBM Plex Mono';
            ctx.fillText(state.visualPrice.toFixed(2), cvs.width - 55, yc + 4);
            
            // Render Ball History on first load or changes
            if(state.gameStarted && document.getElementById('historyContainer').children.length === 0) renderHistoryBlocks();

            requestAnimationFrame(drawLoop);
        }
    </script>
</body>
</html>

